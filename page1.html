<!DOCTYPE html><!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Page 2 &mdash; Jason Wu&#39;s Thoughts and Writings</title><meta name="description" content="关注DevOps、Web安全、Web开发、python、nginx">
        <meta name="viewport" content="width=device-width">


        <link rel="stylesheet/less" href="_static/less/bootstrap.less" type="text/css">
        <link rel="stylesheet/less" href="_static/less/responsive.less" type="text/css">
        <link rel="stylesheet" href="_static/css/bootstrap.css" type="text/css">
        <link rel="stylesheet" href="_static/css/responsive.css" type="text/css">
        <link rel="stylesheet" href="_static/style.css?ver=1.0" type="text/css">
        <link rel="stylesheet" href="_static/main.css?ver=1.0" type="text/css">
        <link rel="stylesheet" href="_static/modern5.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
        <link rel="stylesheet" href="_static/webfont.css" type="text/css"><link rel="shortcut icon" href="_static/favicon.ico" /><!-- Load modernizr and JQuery -->
        <script src="_static/vendor/modernizr-2.6.2.min.js"></script>
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="_static/vendor/jquery-1.8.2.min.js"><\/script>')</script>
        <script src="_static/plugins.js"></script>
        <script src="_static/js/bootstrap.min.js?ver=3.4.2"></script>
        <script src="_static/js/scripts.js?ver=3.4.2"></script>
        <script src="_static/main.js"></script>
        <link rel="next" title="Older" href="page2.html" /><link rel="prev" title="Newer" href="index.html" /><link rel="alternate" type="application/rss+xml" title="RSS" href="http://feed.feedsky.com/JasonWu" /><script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '#',
        VERSION:     '1.0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script><script type="text/javascript" src="_static/underscore.js"></script><script type="text/javascript" src="_static/doctools.js"></script><script type="text/javascript" src="_static/disqus.js"></script></head>
    <body class="home blog custom-background"> 
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]--><header role="banner">
            <div id="inner-header" class="clearfix">
                <div class="navbar navbar-fixed-top">
                    <div class="navbar-inner">
                        <div class="container-fluid nav-container">
                            <nav role="navigation">
                            <a class="brand" id="logo" title="关注DevOps、Web安全、Web开发、python、nginx" href="index.html">Jason Wu&#39;s Thoughts and Writings</a>
                            <div class="nav-collapse">
                                <ul class="nav">
                                    <li class="menu-item">
                                    <a href="archive.html">Archive</a>
                                    </li>
                                    <li class="dropdown menu-item menu-item-type-custom menu-item-object-custom" >
                                    <a data-toggle="dropdown" class="dropdown-toggle" href="#">Categories<b class="caret"></b></a>
                                    <ul class="dropdown-menu"><li class="menu-item menu-item-type-post_type menu-item-object-page" id="menu-item-1"><a href="categories/blog.html">blog</a></li><li class="menu-item menu-item-type-post_type menu-item-object-page" id="menu-item-2"><a href="categories/linux.html">linux</a></li><li class="menu-item menu-item-type-post_type menu-item-object-page" id="menu-item-1"><a href="categories/lua.html">lua</a></li><li class="menu-item menu-item-type-post_type menu-item-object-page" id="menu-item-1"><a href="categories/network.html">network</a></li><li class="menu-item menu-item-type-post_type menu-item-object-page" id="menu-item-1"><a href="categories/nginx.html">nginx</a></li><li class="menu-item menu-item-type-post_type menu-item-object-page" id="menu-item-4"><a href="categories/python.html">python</a></li><li class="menu-item menu-item-type-post_type menu-item-object-page" id="menu-item-2"><a href="categories/security.html">security</a></li></ul>
                                                </li>
                                    <li class="menu-item">
                                    <a href="pages/about.html">About</a>
                                    </li>
                                </ul>
                                    <form action="search.html" class="navbar-search pull-left">
                                        <input type="text" placeholder="Search" class="search-query span2" name="q">
                                    </form>
                            </div>
                            </nav>
                            </div>
                        </div>
                    </div>
                </div> <!-- end #inner-header -->
                </header>
                <div class="container-fluid"><div class="clearfix row-fluid">
                <div id="main" class="span8 clearfix" role="main"><article id="post-54" class="post clearfix" role="article">
                    <div class="timestamp postmeta">
            <span>十月 13, 2012</span>
        </div>
        <div class="section" id="cent-oscx-oracle">
<h1><a href="2012/10/13/centos_install_cx_oracle.html">CENT OS安装cx_Oracle遇到的问题及解决方法</a></h1>
<p>这个是 <tt class="docutils literal"><span class="pre">cx_Oracle</span></tt> 的说明链接http://cx-oracle.sourceforge.net/README.txt，我是采用源码安装
安装过程：</p>
<div class="highlight-bash"><div class="highlight"><pre>wget  http://prdownloads.sourceforge.net/cx-oracle/cx_Oracle-5.0.3.tar.gz?download
tar zxvf   cx_Oracle-5.0.3.tar.gz
<span class="nb">cd </span>cx_Oracle-5.0.3
python setup.py build
python setup.py install
</pre></div>
</div>
<p>下面是检查它是否可以用</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cx_Oracle</span>
<span class="go">接着出现了两个错误，错误信息如下：</span>
<span class="go">/usr/local/lib/python2.6/site-packages/cx_Oracle-5.0.3-py2.6-linux-x86_64.egg/cx_Oracle.py:3:</span>
<span class="go">UserWarning: Module cx_Oracle was already imported from /usr/local/lib/python2.6/site-packages</span>
<span class="go">/cx_Oracle-5.0.3-py2.6-linux-x86_64.egg/cx_Oracle.pyc,</span>
<span class="go">but /usr/local/cx_Oracle-5.0.3 is being added to sys.path</span>
<span class="go">ImportError: libclntsh.so.10.1: cannot open shared object file: No such file or directory</span>
</pre></div>
</div>
<p>下面来说说这两个错误的解决方法，
第一个问题，提示说/usr/local/cx_Oracle-5.0.3已经加入到python的 <tt class="docutils literal"><span class="pre">sys.path</span></tt> 里面了
那么我们就在 <tt class="docutils literal"><span class="pre">sys.path</span></tt> 中去掉这个路径：
具体方法</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">path</span>
<span class="go">['', '/usr/local/lib/python2.6/site-packages/setuptools-0.6c11-py2.6.egg',</span>
<span class="go">'/usr/local/lib/python2.6/site-packages/fudge-0.9.4-py2.6.egg',</span>
<span class="go"> '/usr/local/lib/python2.6/site-packages/python_memcached-1.45-py2.6.egg',</span>
<span class="go"> '/usr/local/lib/python2.6/site-packages/MySQL_python-1.2.3c1-py2.6-linux-x86_64.egg',</span>
<span class="go">'/usr/local/lib/python2.6/site-packages/flup-1.0.3.dev_20100525-py2.6.egg',</span>
<span class="go">'/usr/local/lib/python2.6/site-packages/regex-0.1.20100706.1-py2.6-linux-x86_64.egg',</span>
<span class="go"> '/usr/local/lib/python2.6/site-packages/cx_Oracle-5.0.3-py2.6-linux-x86_64.egg',</span>
<span class="go"> '/usr/local/lib/python26.zip', '/usr/local/lib/python2.6', '/usr/local/lib/python2.6/plat-linux2',</span>
<span class="go"> '/usr/local/lib/python2.6/lib-tk', '/usr/local/lib/python2.6/lib-old',</span>
<span class="go">'/usr/local/lib/python2.6/lib-dynload', '/usr/local/lib/python2.6/site-packages',</span>
<span class="go"> '/usr/local/lib/python2.6/site-packages/PIL', '/usr/local/cx_Oracle-5.0.3']</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s">r'/usr/local/cx_Oracle-5.0.3'</span><span class="p">)</span>
</pre></div>
</div>
<p>第一个问题解决，接着第二个问题，这个网上有解决方案，下面说说解决方法：
这个的原因是 <tt class="docutils literal"><span class="pre">Oracle</span></tt> 的路径没有设定</p>
<div class="highlight-bash"><div class="highlight"><pre>locate libclntsh.so.10.1
/opt/oracle/product/10.2/db_1/lib/libclntsh.so.10.1
/opt/oracle/product/10.2/db_1/lib32/libclntsh.so.10.1
<span class="nb">echo</span> /opt/oracle/product/10.2/db_1/lib/ &gt;&gt; /etc/ld.so.conf
ldconfig
</pre></div>
</div>
<p>就这样第二个问题解决
再试一下：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cx_Oracle</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Jason Wu</span>
        </div>
        <div class="categories">
            <span>
                Filed under:
                <a href="categories/python.html">python</a></span>
        </div>
        <div class="tags">
            <span>
                Tags:
                <a class="label"; rel="tag"; href="tags/cx_oracle.html">cx_oracle</a>
                <a class="label"; rel="tag"; href="tags/python.html">python</a>
                </span>
        </div>
        <div class="comments">
            <a href="http://jasonwu.me/2012/10/13/centos_install_cx_oracle.html#disqus_thread" data-disqus-identifier="2012/10/13/centos_install_cx_oracle">Leave a comment</a>
        </div>
    </div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>十月 13, 2012</span>
        </div>
        <div class="section" id="pythonlambda">
<h1><a href="2012/10/13/introduce_to_python_lambda.html">python的lambda函数介绍</a></h1>
<p>今天在论坛上看到有人问的一个关于如何从一个python的字典中取到value中最大的那个key值，里面用到了 <tt class="docutils literal"><span class="pre">lambda</span></tt> 函数，今天那就大致介绍下 <tt class="docutils literal"><span class="pre">lambda</span></tt> 是个什么东东。
python支持创建一种匿名的函数（一种没绑定名字的函数），这种函数叫做lambda，这个和fp(函数编程)里面的lambda的含义并不是完全一致，下面这段代码将展示 <tt class="docutils literal"><span class="pre">lambda</span></tt> 和普通函数之间的区别</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span> <span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">f</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="go">64</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">g</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="go">64</span>
</pre></div>
</div>
<p>g()是一个 lambda 函数，完成同上面普通函数相同的事情。注意这里的简短的语法：在参数列表周围没有括号，而且忽略了 return 关键字 (隐含存在，因为整个函数只有一行)。而且，该函数没有函数名称，但是可以将它赋值给一个变量进行调用。
使用 lambda 函数时甚至不需要将它赋值给一个变量。这可能不是世上最有用的东西，它只是展示了 lambda 函数只是一个内联函数。</p>
<p>总的来说，lambda 函数可以接收任意多个参数 (包括可选参数) 并且返回单个表达式的值。lambda 函数不能包含命令，包含的表达式不能超过一个。不要试图向 lambda 函数中塞入太多的东西；如果你需要更复杂的东西，应该定义一个普通函数，然后想让它多长就多长。
这里只是大致介绍一下，想深入研究的可以看文章后面附的文档，这里回到开头的问题，如果返回一个字典中最大的value值的key，下面为代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span><span class="s">'a'</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="s">'b'</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="s">'c'</span><span class="p">:</span><span class="mi">3</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">(),</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span><span class="nb">dict</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
<span class="go">'c'</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>下面来大致解释这段代码，先定义了一个列表，通过使用key参数改变了max比较列表元素的方法，最终达到了取得value值最大的key的目的。</p>
<p>接下来讲一下，python字典的 <tt class="docutils literal"><span class="pre">iterkeys</span></tt> <tt class="docutils literal"><span class="pre">iteritems</span></tt> <tt class="docutils literal"><span class="pre">itervalues</span></tt> 这三个方法，字典对象也提供keys，items，values这三个方法，那前面的三种方法和后面的三种方法有什么不一样呢，我们大致运行一下就可以知道了，前面的三个方法返回迭代器对象，而后三种方法返回的为列表对象，使用前三种方法更高效一些，后三种方法对内存占用比较大，在python 3.0中取消了iterkeys，iteritems，itervalues这三个方法，将keys，items，values这三个方法功能改为原来iter*的功能。</p>
<p><strong>参考文档:</strong></p>
<ul class="simple">
<li>Python: <a class="reference external" href="http://www.secnetix.de/olli/Python/lambda_functions.hawk">Lambda Functions</a></li>
<li>Python: <a class="reference external" href="http://docs.python.org/library/functions.html">Built-in Functions</a></li>
</ul>
</div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Jason Wu</span>
        </div>
        <div class="categories">
            <span>
                Filed under:
                <a href="categories/python.html">python</a></span>
        </div>
        <div class="tags">
            <span>
                Tags:
                <a class="label"; rel="tag"; href="tags/lambda.html">lambda</a>
                <a class="label"; rel="tag"; href="tags/python.html">python</a>
                </span>
        </div>
        <div class="comments">
            <a href="http://jasonwu.me/2012/10/13/introduce_to_python_lambda.html#disqus_thread" data-disqus-identifier="2012/10/13/introduce_to_python_lambda">Leave a comment</a>
        </div>
    </div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>九月 11, 2012</span>
        </div>
        <div class="section" id="lvs">
<h1><a href="2012/09/11/detailed_lvs_difference_between_the_three_models.html"><a class="toc-backref" href="#id13">LVS的三种模式区别详解</a></a></h1>
<div class="contents topic" id="table-of-contents">
<p class="topic-title first">内容索引 Table of Contents</p>
<ul class="simple">
<li><a class="reference internal" href="2012/09/11/detailed_lvs_difference_between_the_three_models.html#lvs" id="id13">LVS的三种模式区别详解</a><ul>
<li><a class="reference internal" href="2012/09/11/detailed_lvs_difference_between_the_three_models.html#dr-direct-routing" id="id14">DR模式：(Direct Routing)直接路由模式</a><ul>
<li><a class="reference internal" href="2012/09/11/detailed_lvs_difference_between_the_three_models.html#dr" id="id15">DR模式的网络拓扑：</a></li>
<li><a class="reference internal" href="2012/09/11/detailed_lvs_difference_between_the_three_models.html#id1" id="id16">DR模式的工作过程：</a></li>
<li><a class="reference internal" href="2012/09/11/detailed_lvs_difference_between_the_three_models.html#id2" id="id17">DR模式的几个细节：</a><ul>
<li><a class="reference internal" href="2012/09/11/detailed_lvs_difference_between_the_three_models.html#lvsreal-server" id="id18">LVS和Real-server必须在相同的网段</a></li>
<li><a class="reference internal" href="2012/09/11/detailed_lvs_difference_between_the_three_models.html#id3" id="id19">LVS不需要开启路由转发：</a></li>
<li><a class="reference internal" href="2012/09/11/detailed_lvs_difference_between_the_three_models.html#arp" id="id20">ARP问题：</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="2012/09/11/detailed_lvs_difference_between_the_three_models.html#ip-tunneling" id="id21">IP Tunneling模式：</a><ul>
<li><a class="reference internal" href="2012/09/11/detailed_lvs_difference_between_the_three_models.html#id4" id="id22">IP Tunneling的拓扑图</a></li>
<li><a class="reference internal" href="2012/09/11/detailed_lvs_difference_between_the_three_models.html#id5" id="id23">IP Tunneling的工作过程</a></li>
<li><a class="reference internal" href="2012/09/11/detailed_lvs_difference_between_the_three_models.html#id6" id="id24">IP Tunneling的几个细节问题</a><ul>
<li><a class="reference internal" href="2012/09/11/detailed_lvs_difference_between_the_three_models.html#ip" id="id25">IP封包的过程：(如图)</a></li>
<li><a class="reference internal" href="2012/09/11/detailed_lvs_difference_between_the_three_models.html#id7" id="id26">LVS和Real-server不需要在一个网段：</a></li>
<li><a class="reference internal" href="2012/09/11/detailed_lvs_difference_between_the_three_models.html#real-server" id="id27">Real-server的系统设置：</a></li>
<li><a class="reference internal" href="2012/09/11/detailed_lvs_difference_between_the_three_models.html#id8" id="id28">ARP问题：</a></li>
<li><a class="reference internal" href="2012/09/11/detailed_lvs_difference_between_the_three_models.html#id9" id="id29">内核的包转发：</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="2012/09/11/detailed_lvs_difference_between_the_three_models.html#nat" id="id30">NAT模式：</a><ul>
<li><a class="reference internal" href="2012/09/11/detailed_lvs_difference_between_the_three_models.html#id10" id="id31">NAT模式的拓扑图</a></li>
<li><a class="reference internal" href="2012/09/11/detailed_lvs_difference_between_the_three_models.html#id11" id="id32">NAT模式的工作过程:</a></li>
<li><a class="reference internal" href="2012/09/11/detailed_lvs_difference_between_the_three_models.html#id12" id="id33">NAT模式的几个细节问题</a><ul>
<li><a class="reference internal" href="2012/09/11/detailed_lvs_difference_between_the_three_models.html#natbugs" id="id34">NAT模式的Bugs</a></li>
<li><a class="reference internal" href="2012/09/11/detailed_lvs_difference_between_the_three_models.html#icmp" id="id35">ICMP重定向问题</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="dr-direct-routing">
<h2><a class="toc-backref" href="#id14">DR模式：(Direct Routing)直接路由模式</a></h2>
<div class="section" id="dr">
<h3><a class="toc-backref" href="#id15">DR模式的网络拓扑：</a></h3>
<img alt="http://farm7.static.flickr.com/6236/6322179853_5899c2dfb6_z.jpg" src="http://farm7.static.flickr.com/6236/6322179853_5899c2dfb6_z.jpg" style="width: 600px;"/>
</div>
<div class="section" id="id1">
<h3><a class="toc-backref" href="#id16">DR模式的工作过程：</a></h3>
<p>当一个client发送一个WEB请求到VIP，LVS服务器根据VIP选择对应的real-server的Pool，根据算法，在Pool中选择一台Real-server，LVS在hash表中记录该次连接，然后将client的请求包发给选择的Real-server，最后选择的Real-server把应答包直接传给client；当client继续发包过来时，LVS根据更才记录的hash表的信息，将属于此次连接的请求直接发到刚才选择的Real-server上；当连接中止或者超时，hash表中的记录将被删除。</p>
</div>
<div class="section" id="id2">
<h3><a class="toc-backref" href="#id17">DR模式的几个细节：</a></h3>
<div class="section" id="lvsreal-server">
<h4><a class="toc-backref" href="#id18">LVS和Real-server必须在相同的网段</a></h4>
<p>DR模式在转发client的包时，只修改了包目的MAC地址为选定的Real-server的mac地址，所以如果LVS和Real-server在不通的广播域内，那么Real-server就没办法接收到转发的包。下面是mac地址的修改过程：</p>
<img alt="http://farm7.static.flickr.com/6100/6322179927_eb8e928a02_z.jpg" src="http://farm7.static.flickr.com/6100/6322179927_eb8e928a02_z.jpg" style="width: 600px;"/>
</div>
<div class="section" id="id3">
<h4><a class="toc-backref" href="#id19">LVS不需要开启路由转发：</a></h4>
<p>LVS的DR模式不需要开启路由转发功能，就可以正常的工作，出于安全考虑，如果不需要转发功能，最好关闭。</p>
</div>
<div class="section" id="arp">
<h4><a class="toc-backref" href="#id20">ARP问题：</a></h4>
<p>通常，DR模式需要在Real-server上配置VIP，配置的方式为：</p>
<div class="highlight-bash"><div class="highlight"><pre>/sbin/ifconfig lo:0 inet VIP netmask 255.255.255.255
</pre></div>
</div>
<p>原因在于，当LVS把client的包转发给Real-server时，因为包的目的IP地址是VIP，那么如果Real-server收到这个包后，发现包的目的IP不是自己的系统IP，那么就会认为这个包不是发给自己的，就会丢弃这个包，所以需要将这个IP地址绑到网卡上；当发送应答包给client时，Real-server就会把包的源和目的地址调换，直接回复给client。</p>
<p><strong>关于ARP广播：</strong></p>
<ul class="simple">
<li>上面绑定VIP的掩码是”255.255.255.255″，说明广播地址是其本身，那么他就不会将ARP发送到实际的自己该属于的广播域了，这样防止与LVS上VIP冲突，而导致IP冲突。</li>
<li>另外在Linux的Real-server上，需要设置ARP的sysctl选项:（下面是举例说明设置项的）</li>
</ul>
<p>假设服务器上ip地址如下所示:</p>
<div class="highlight-python"><pre>System Interface MAC Address IP Address
HN eth0 00:0c:29:b3:a2:54 192.168.18.10
HN eth3 00:0c:29:b3:a2:68 192.168.18.11
HN eth4 00:0c:29:b3:a2:5e 192.168.18.12
client eth0 00:0c:29:d2:c7:aa 192.168.18.129</pre>
</div>
<p>当我从192.168.18.129 ping 192.168.18.10时，tcpdump抓包发现:</p>
<div class="highlight-python"><pre>00:0c:29:d2:c7:aa &gt; ff:ff:ff:ff:ff:ff, ARP, length 60: arp who-has 192.168.18.10 tell 192.168.18.129
00:0c:29:b3:a2:5e &gt; 00:0c:29:d2:c7:aa, ARP, length 60: arp reply 192.168.18.10 is-at 00:0c:29:b3:a2:5e
00:0c:29:b3:a2:54 &gt; 00:0c:29:d2:c7:aa, ARP, length 60: arp reply 192.168.18.10 is-at 00:0c:29:b3:a2:54
00:0c:29:b3:a2:68 &gt; 00:0c:29:d2:c7:aa, ARP, length 60: arp reply 192.168.18.10 is-at 00:0c:29:b3:a2:68
00:0c:29:d2:c7:aa &gt; 00:0c:29:b3:a2:5e, IPv4, length 98: 192.168.18.129 &gt; 192.168.18.10: ICMP echo request, id 32313, seq 1, length 64
00:0c:29:b3:a2:54 &gt; 00:0c:29:d2:c7:aa, IPv4, length 98: 192.168.18.10 &gt; 192.168.18.129: ICMP echo reply, id 32313, seq 1, length 64
00:0c:29:d2:c7:aa &gt; 00:0c:29:b3:a2:5e, IPv4, length 98: 192.168.18.129 &gt; 192.168.18.10: ICMP echo request, id 32313, seq 2, length 64
00:0c:29:b3:a2:54 &gt; 00:0c:29:d2:c7:aa, IPv4, length 98: 192.168.18.10 &gt; 192.168.18.129: ICMP echo reply, id 32313, seq 2, length 64
00:0c:29:b3:a2:54 &gt; 00:0c:29:d2:c7:aa, ARP, length 60: arp who-has 192.168.18.129 tell 192.168.18.10
00:0c:29:d2:c7:aa &gt; 00:0c:29:b3:a2:54, ARP, length 60: arp reply 192.168.18.129 is-at 00:0c:29:d2:c7:aa</pre>
</div>
<p>三个端口都发送了arp的reply包，但是192.168.18.129使用的第一个回应的eth4的mac地址作为ping请求的端口，由于192.168.18.10是icmp包中的目的地址，那么ping的应答包，会从eth0端口发出。</p>
<p>如果Real-server有个多个网卡，每个网卡在不同的网段，那么可以过滤掉非本网卡ARP请求的回应；但是如果多个网卡的ip在一个网段，那么就不行了。</p>
<div class="highlight-bash"><div class="highlight"><pre>sysctl -w net.ipv4.conf.all.arp_filter<span class="o">=</span>1
</pre></div>
</div>
<p>对于多个接口在相同网段可以设置下面的来防止：</p>
<div class="highlight-bash"><div class="highlight"><pre>sysctl -w net.ipv4.conf.all.arp_ignore<span class="o">=</span>1
sysctl -w net.ipv4.conf.all.arp_announce<span class="o">=</span>2
</pre></div>
</div>
<p>还是从192.168.18.129 ping 192.168.18.10时，tcpdump抓包发现:</p>
<div class="highlight-python"><pre>00:0c:29:d2:c7:aa &gt; ff:ff:ff:ff:ff:ff, ARP, length 60: arp who-has 192.168.18.10 tell 192.168.18.129
00:0c:29:b3:a2:54 &gt; 00:0c:29:d2:c7:aa, ARP, length 60: arp reply 192.168.18.10 is-at 00:0c:29:b3:a2:54
00:0c:29:d2:c7:aa &gt; 00:0c:29:b3:a2:54, IPv4, length 98: 192.168.18.129 &gt; 192.168.18.10: ICMP echo request, id 32066, seq 1, length 64
00:0c:29:b3:a2:54 &gt; 00:0c:29:d2:c7:aa, IPv4, length 98: 192.168.18.10 &gt; 192.168.18.129: ICMP echo reply, id 32066, seq 1, length 64
00:0c:29:d2:c7:aa &gt; 00:0c:29:b3:a2:54, IPv4, length 98: 192.168.18.129 &gt; 192.168.18.10: ICMP echo request, id 32066, seq 2, length 64
00:0c:29:b3:a2:54 &gt; 00:0c:29:d2:c7:aa, IPv4, length 98: 192.168.18.10 &gt; 192.168.18.129: ICMP echo reply, id 32066, seq 2, length 64
00:0c:29:b3:a2:54 &gt; 00:0c:29:d2:c7:aa, ARP, length 60: arp who-has 192.168.18.129 tell 192.168.18.10
00:0c:29:d2:c7:aa &gt; 00:0c:29:b3:a2:54, ARP, length 60: arp reply 192.168.18.129 is-at 00:0c:29:d2:c7:aa</pre>
</div>
<p>看到了么，现在只有eth0会回应arp请求了。</p>
<p><strong>arp报文格式：</strong></p>
<img alt="http://farm7.static.flickr.com/6219/6324726842_6f0aea5dab_z.jpg" src="http://farm7.static.flickr.com/6219/6324726842_6f0aea5dab_z.jpg"/>
<p>请求报文：MAC地址字段是空的。
应答报文：所有字段都又内容。:</p>
<div class="highlight-python"><pre>The arp_announce/arp_ignore reference：

arp_announce – INTEGER
Define different restriction levels for announcing the local
source IP address from IP packets in ARP requests sent on
interface:
0 – (default) Use any local address, configured on any interface
1 – Try to avoid local addresses that are not in the target’s
subnet for this interface. This mode is useful when target
hosts reachable via this interface require the source IP
address in ARP requests to be part of their logical network
configured on the receiving interface. When we generate the
request we will check all our subnets that include the
target IP and will preserve the source address if it is from
such subnet. If there is no such subnet we select source
address according to the rules for level 2.
2 – Always use the best local address for this target.
In this mode we ignore the source address in the IP packet
and try to select local address that we prefer for talks with
the target host. Such local address is selected by looking
for primary IP addresses on all our subnets on the outgoing
interface that include the target IP address. If no suitable
local address is found we select the first local address
we have on the outgoing interface or on all other interfaces,
with the hope we will receive reply for our request and
even sometimes no matter the source IP address we announce.

The max value from conf/{all,interface}/arp_announce is used.

Increasing the restriction level gives more chance for
receiving answer from the resolved target while decreasing
the level announces more valid sender’s information.</pre>
</div>
<p><tt class="docutils literal"><span class="pre">arp_announce</span></tt> 用来限制，是否使用发送的端口的ip地址来设置ARP的源地址：</p>
<ul class="simple">
<li>“0″代表是用ip包的源地址来设置ARP请求的源地址。</li>
<li>“1″代表不使用ip包的源地址来设置ARP请求的源地址，如果ip包的源地址是和该端口的IP地址相同的子网，那么用ip包的源地址，来设置ARP请求的源地址，否则使用”2″的设置。</li>
<li>“2″代表不使用ip包的源地址来设置ARP请求的源地址，而由系统来选择最好的接口来发送。</li>
</ul>
<p>当内网的机器要发送一个到外部的ip包，那么它就会请求路由器的Mac地址，发送一个arp请求，这个arp请求里面包括了自己的ip地址和Mac地址，而linux默认是使用ip的源ip地址作为arp里面的源ip地址，而不是使用发送设备上面的 ，这样在lvs这样的架构下，所有发送包都是同一个VIP地址，那么arp请求就会包括VIP地址和设备 Mac，而路由器收到这个arp请求就会更新自己的arp缓存，这样就会造成ip欺骗了，VIP被抢夺，所以就会有问题。</p>
<p>现在假设一个场景来解释 <tt class="docutils literal"><span class="pre">arp_announce</span></tt> ：</p>
<div class="highlight-rst"><div class="highlight"><pre>Real-server的ip地址：202.106.1.100(public local address)，
172.16.1.100(private local address)，
202.106.1.254(VIP)
</pre></div>
</div>
<p>如果发送到client的ip包产生的arp请求的源地址是202.106.1.254(VIP),那么LVS上的VIP就会被冲掉，因为交换机上现在的arp对应关系是Real-server上的VIP对应自己的一个MAC，那么LVS上的VIP就失效了。:</p>
<div class="highlight-python"><pre>arp_ignore – INTEGER
Define different modes for sending replies in response to
received ARP requests that resolve local target IP addresses:
0 – (default): reply for any local target IP address, configured
on any interface
1 – reply only if the target IP address is local address
configured on the incoming interface
2 – reply only if the target IP address is local address
configured on the incoming interface and both with the
sender’s IP address are part from same subnet on this interface
3 – do not reply for local addresses configured with scope host,
only resolutions for global and link addresses are replied
4-7 – reserved
8 – do not reply for all local addresses

The max value from conf/{all,interface}/arp_ignore is used
when ARP request is received on the {interface}</pre>
</div>
<p>“0″,代表对于arp请求，任何配置在本地的目的ip地址都会回应，不管该arp请求的目的地址是不是接口的ip；如果有多个网卡，并且网卡的ip都是一个子网，那么从一个端口进来的arp请求，别的端口也会发送回应。
“1″,代表如果arp请求的目的地址，不是该arp请求包进入的接口的ip地址，那么不回应。
“2″,要求的更苛刻，除了”1″的条件外，还必须要求arp发送者的ip地址和arp请求进入的接口的ip地址是一个网段的。
(后面略)</p>
</div>
</div>
</div>
<div class="section" id="ip-tunneling">
<h2><a class="toc-backref" href="#id21">IP Tunneling模式：</a></h2>
<div class="section" id="id4">
<h3><a class="toc-backref" href="#id22">IP Tunneling的拓扑图</a></h3>
<img alt="http://farm7.static.flickr.com/6094/6323980713_082c909dd5_b.jpg" src="http://farm7.static.flickr.com/6094/6323980713_082c909dd5_b.jpg" style="width: 600px;"/>
</div>
<div class="section" id="id5">
<h3><a class="toc-backref" href="#id23">IP Tunneling的工作过程</a></h3>
<p>1&gt; client 发送request包到LVS服务器的VIP上。</p>
<p>2&gt; VIP按照算法选择后端的一个Real-server，并将记录一条消息到hash表中，然后将client的request包封装到一个新的IP包里，新IP包的目的IP是Real-server的IP，然后转发给Real-server。</p>
<p>3&gt; Real-server收到包后，解封装，取出client的request包，发现他的目的地址是VIP，而Real-server发现在自己的lo:0口上有这个IP地址，于是处理client的请求，然后将relpy这个request包直接发给client。</p>
<p>4&gt; 该client的后面的request包，LVS直接按照hash表中的记录直接转发给Real-server，当传输完毕或者连接超时，那么将删除hash表中的记录。</p>
</div>
<div class="section" id="id6">
<h3><a class="toc-backref" href="#id24">IP Tunneling的几个细节问题</a></h3>
<div class="section" id="ip">
<h4><a class="toc-backref" href="#id25">IP封包的过程：(如图)</a></h4>
<img alt="http://farm7.static.flickr.com/6237/6324734370_e543f436fb_z.jpg" src="http://farm7.static.flickr.com/6237/6324734370_e543f436fb_z.jpg" style="width: 600px;"/>
</div>
<div class="section" id="id7">
<h4><a class="toc-backref" href="#id26">LVS和Real-server不需要在一个网段：</a></h4>
<p>由于通过IP Tunneling 封装后，封装后的IP包的目的地址为Real-server的IP地址，那么只要Real-server的地址能路由可达，Real-server在什么网络里都可以，这样可以减少对于公网IP地址的消耗，但是因为要处理IP Tunneling封装和解封装的开销，那么效率不如DR模式。</p>
</div>
<div class="section" id="real-server">
<h4><a class="toc-backref" href="#id27">Real-server的系统设置：</a></h4>
<p>由于需要Real-server支持IP Tunneling，所以设置与DR模式不太一样，LVS不需要设置tunl设备，LVS本身可以进行封装
i) 需要配置VIP在tunl设备上：(VIP：172.16.1.254)</p>
<div class="highlight-bash"><div class="highlight"><pre>shell&gt; ifconfig tunl0 172.16.1.254 netmask 255.255.255.255
shell&gt; ifconfig tunl0
tunl0 Link encap:IPIP Tunnel HWaddr
inet addr:172.16.1.254 Mask:255.255.255.255
UP RUNNING NOARP MTU:1480 Metric:1
RX packets:0 errors:0 dropped:0 overruns:0 frame:0
TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:0 <span class="o">(</span>0.0 b<span class="o">)</span> TX bytes:0 <span class="o">(</span>0.0 b<span class="o">)</span>
</pre></div>
</div>
<p>当添加tunl0设备时，自动载入需要的模块：</p>
<div class="highlight-bash"><div class="highlight"><pre>shell&gt; lsmod |grep ipip
ipip 7516 0
tunnel4 2700 1 ipip
</pre></div>
</div>
<p>其中，ipip依赖于tunnel4，假如现在删除tunnel4的话：</p>
<div class="highlight-bash"><div class="highlight"><pre>shell&gt; rmmod tunnel4
ERROR: Module tunnel4 is in use by ipip
</pre></div>
</div>
<p>如果添加tunl0失败，那么可能是内核没有开启tunneling功能，默认是以模块形式，加载到内核里的：</p>
<img alt="http://farm7.static.flickr.com/6115/6323980779_b0369d8de9.jpg" src="http://farm7.static.flickr.com/6115/6323980779_b0369d8de9.jpg"/>
</div>
<div class="section" id="id8">
<h4><a class="toc-backref" href="#id28">ARP问题：</a></h4>
<p>如果LVS和Real-server不在一个网络内，不需要处理ARP问题，如果在相同网络，那么处理方法和DR模式一样，但是如果一样，我就不知道选择tun模式有什么好理由了，DR似乎效率更高些吧。</p>
</div>
<div class="section" id="id9">
<h4><a class="toc-backref" href="#id29">内核的包转发：</a></h4>
<p>IP Tunneling模式不需要开启ip_forward功能。</p>
</div>
</div>
</div>
<div class="section" id="nat">
<h2><a class="toc-backref" href="#id30">NAT模式：</a></h2>
<div class="section" id="id10">
<h3><a class="toc-backref" href="#id31">NAT模式的拓扑图</a></h3>
<img alt="http://farm7.static.flickr.com/6099/6323980789_b90f2546bf_b.jpg" src="http://farm7.static.flickr.com/6099/6323980789_b90f2546bf_b.jpg" style="width: 600px;"/>
</div>
<div class="section" id="id11">
<h3><a class="toc-backref" href="#id32">NAT模式的工作过程:</a></h3>
<img alt="http://farm7.static.flickr.com/6117/6324734426_fc573643bf.jpg" src="http://farm7.static.flickr.com/6117/6324734426_fc573643bf.jpg"/>
<div class="highlight-rst"><div class="highlight"><pre>client：202.100.1.2
VIP：202.103.106.5
Real-server：172.16.0.2 和 172.16.0.3（提供http和ftp服务）
</pre></div>
</div>
<p>1&gt; client发送request到LVS的VIP上，VIP选择一个Real-server，并记录连接信息到hash表中，然后修改client的request的目的IP地址为Real-server的地址，将请求发给Real-server;</p>
<p>2&gt; Real-server收到request包后，发现目的IP是自己的IP，于是处理请求，然后发送reply给LVS;</p>
<p>3&gt; LVS收到reply包后，修改reply包的的源地址为VIP，发送给client;</p>
<p>4&gt; 从client来的属于本次连接的包，查hash表，然后发给对应的Real-server。</p>
<p>5&gt; 当client发送完毕，此次连接结束或者连接超时，那么LVS自动从hash表中删除此条记录。</p>
<p>下面是地址转换的过程：</p>
<img alt="http://farm7.static.flickr.com/6239/6323980835_6e32e61090_b.jpg" src="http://farm7.static.flickr.com/6239/6323980835_6e32e61090_b.jpg" style="width: 600px;"/>
</div>
<div class="section" id="id12">
<h3><a class="toc-backref" href="#id33">NAT模式的几个细节问题</a></h3>
<div class="section" id="natbugs">
<h4><a class="toc-backref" href="#id34">NAT模式的Bugs</a></h4>
<ul class="simple">
<li>在Linux的2.6版本，LVS-NAT不能做防火墙，在只有一个网关的情况下，没有任何问题。</li>
<li>防火墙不兼容：LVS的架构中，LVS的前端不能设置防火墙，修复的补丁”NFCT” patch。</li>
<li>源路由问题</li>
</ul>
</div>
<div class="section" id="icmp">
<h4><a class="toc-backref" href="#id35">ICMP重定向问题</a></h4>
<p>一. 对于路由器来说，只有当如下条件同时满足的时候，才进行重定向</p>
<ul class="simple">
<li>数据包的入接口和路由后的指定的出接口是同一个接口。</li>
<li>数据包的源IP地址和该包应走的下一跳IP地址属于同一个网段。</li>
<li>数据报非源路由的（这种情况应该比较少见了，源路由多见于Token Ring）。</li>
<li>系统开启重定向功能。</li>
</ul>
<dl class="docutils">
<dt><strong>例如：</strong></dt>
<dd>两个路由器都开启了IP重定向功能。HostA 的默认网关为1.1.1.1。当HostA要和不在同一网段中的HostB通信的时候，会把数据报递交给默认网关RT1。然而RT1经过查找发现到达3.3.3.3的路径下一跳恰恰是经由自己的E0/1口的RT2接口1.1.1.2。满足上述条件，将会发生重定向。</dd>
</dl>
<p>二. LVS为什么会产生ICMP重定向问题：
* 在LVS-NAT模式下，如果LVS的各个成员，client，LVS，Real-server在同一个网段(比如：192.168.1.*/24)；</p>
<ul class="simple">
<li>当Real-server将Reply发送回LVS时，Reply包是 RIP -&gt; CIP的，LVS看到RIP-&gt; CIP实际上根本没必要经过LVS，直接到网关就行了，因为大家在一个网段，所以产生ICMP重定向发送给Real-server；</li>
<li>Real-server收到ICMP重定向包后，如果Real-server的ICMP重定向开启了，Real-server就会处理ICMP重定向包，直接将Reply包发给网关，这时Reply包头并没有被LVS重写，所以LVS负载出现了问题。</li>
</ul>
<p>注意：这种情况只会出现在所有的LVS的成员都在一个网段的情况下。</p>
<p>重定向的处理办法（Real-server的配置）：</p>
<p>1&gt; 关闭Real-server的重定向，忽略LVS发来的重定向包</p>
<p>2&gt; 删除到网段的路由：</p>
<img alt="http://farm7.static.flickr.com/6105/6324754200_9780818531_z.jpg" src="http://farm7.static.flickr.com/6105/6324754200_9780818531_z.jpg" style="width: 600px;"/>
<p>执行：</p>
<div class="highlight-bash"><div class="highlight"><pre>realserver:/etc/lvs#route del -net 192.168.1.0 netmask 255.255.255.0 dev eth0
</pre></div>
</div>
<p>路由已经被删除了：</p>
<img alt="http://farm7.static.flickr.com/6214/6324754218_a6258829e5_z.jpg" src="http://farm7.static.flickr.com/6214/6324754218_a6258829e5_z.jpg" style="width: 600px;"/>
<p>3&gt; LVS-NAT模式支持四层的端口重写：
LVS-DR，LVS-TUN不能修改client发来的请求的目的端口，但是LVS-NAT可以，参考命令：</p>
<div class="highlight-bash"><div class="highlight"><pre>shell&gt; ipvsadm -a -t VIP:PORT -r RIP:NEWPORT -m -w 1
</pre></div>
</div>
<p>LVS的三种转发模式就先说到这吧，具体的细节可以参考LVS的HOWTO文档。</p>
</div>
</div>
</div>
</div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Jason Wu</span>
        </div>
        
        
        <div class="comments">
            <a href="http://jasonwu.me/2012/09/11/detailed_lvs_difference_between_the_three_models.html#disqus_thread" data-disqus-identifier="2012/09/11/detailed_lvs_difference_between_the_three_models">Leave a comment</a>
        </div>
    </div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>九月 11, 2012</span>
        </div>
        <div class="section" id="vmware-several-modules-must-be-compiled-and-loaded-into-the-running-kernel">
<h1><a href="2012/09/11/vmware_several_modules_must_be_compiled_and_loaded_into_the_running_kernel.html">VMware-several-modules-must-be-compiled-and-loaded-into-the-running-kernel</a></h1>
<p>在ubuntu 12.04上安装vmware workstation 8.02,</p>
<p>在vmware kernel module updater这个窗口上，编译第二步Virtual Network Device 时出现错误</p>
<p>查看Log，有如下报错：</p>
<div class="highlight-rst"><div class="highlight"><pre>2012-06-24T14:56:24.833+08:00| vthread-3| I120: Your GCC version: 4.6
2012-06-24T14:56:24.839+08:00| vthread-3| I120: Your GCC version: 4.6
2012-06-24T14:56:24.855+08:00| vthread-3| I120: Header path /lib/modules/3.2.0-25-generic/build/include for kernel release 3.2.0-25-generic is valid.
2012-06-24T14:56:24.867+08:00| vthread-3| I120: Trying to find a suitable PBM set for kernel 3.2.0-25-generic.
</pre></div>
</div>
<p>解决方案：</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="c"># cd /usr/lib/vmware/modules;</span>
<span class="c"># wget http://pavlinux.ru/vmware/8.0.2/source.tar.lzma;</span>
<span class="c"># tar -xf source.tar.lzma;</span>
<span class="c"># vmware-modconfig --console --install-all</span>
</pre></div>
</div>
<img alt="http://pavlinux.ru/vmware/8.0.2/make.png" src="http://pavlinux.ru/vmware/8.0.2/make.png"/>
</div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Jason Wu</span>
        </div>
        
        <div class="tags">
            <span>
                Tags:
                <a class="label"; rel="tag"; href="tags/vmware.html">vmware</a>
                </span>
        </div>
        <div class="comments">
            <a href="http://jasonwu.me/2012/09/11/vmware_several_modules_must_be_compiled_and_loaded_into_the_running_kernel.html#disqus_thread" data-disqus-identifier="2012/09/11/vmware_several_modules_must_be_compiled_and_loaded_into_the_running_kernel">Leave a comment</a>
        </div>
    </div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>九月 08, 2012</span>
        </div>
        <div class="section" id="lvs">
<h1><a href="2012/09/08/adjust_nic_irq_for_lvs.html">LVS网卡软中断配置</a></h1>
<p>这是之前做LVS的网卡软中断配置时整理的一个文档，网上的资料不是很全，将配置方法share给大家。</p>
<p>为什么要配置网卡软中断，主要是因为在网络非常 heavy 的情况下，对于文件服务器、高流量 Web 服务器这样的应用来说，把不同的网卡 IRQ 均衡绑定到不同的 CPU 上将会减轻某个 CPU 的负担，提高多个 CPU 整体处理中断的能力。合理的根据自己的生产环境和应用的特点来平衡 IRQ 中断有助于提高系统的整体吞吐能力和性能。
先看下未升级之前的效果：可以看到网卡软中断被分配到了两个指定的CPU核心上:</p>
<img alt="http://farm8.staticflickr.com/7067/6928555291_87c0dfcc68_z.jpg" src="http://farm8.staticflickr.com/7067/6928555291_87c0dfcc68_z.jpg"/>
<p>经过升级内核调整参数后的效果：</p>
<img alt="http://farm8.staticflickr.com/7061/6928555437_450d1a548b_z.jpg" src="http://farm8.staticflickr.com/7061/6928555437_450d1a548b_z.jpg" style="width: 600px;"/>
<p>软中断被均匀的分配到8个核心上，下面来说下具体过程</p>
<div class="section" id="id1">
<h2>第一步</h2>
<p>将内核升级到2.6.32以上，升级过程略去</p>
<div class="highlight-bash"><div class="highlight"><pre>为什么要将2.6.18内核升级到2.6.32？这个主要是因为2.6.18还不支持RPS这个特性那什么是rps呢？具体可以参看：
http://lwn.net/Articles/328339/
http://lwn.net/Articles/378617/
为什么要将2.6.18内核升级到2.6.32？
这个主要是因为2.6.18不支持RPS这个特性
那什么是rps呢？具体可以参看：
http://lwn.net/Articles/328339/
http://lwn.net/Articles/378617/
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h2>第二步：</h2>
<p>如果你的服务器网卡和我一样是Broadcom的，那么你就得做这一步，不是请跳到第三步</p>
<img alt="http://farm8.staticflickr.com/7052/6928573033_5dd56c20dc_z.jpg" src="http://farm8.staticflickr.com/7052/6928573033_5dd56c20dc_z.jpg" style="width: 600px; height: 44px;"/>
<p>在/etc/modprobe.conf加上下面这行： options bnx2 disable_msi=1
改完这个重新加载下网卡模块modprobe -r bnx2;modprobe bnx2或者重新启动服务器。</p>
<div class="highlight-bash"><div class="highlight"><pre>为什么要加这个？
这个主要是因为broadcom网卡开启msi后，会造成后面的修改smp_affinity丌生效，intel的网卡没这个问题。

msi是什么？下面的链接有解析：
http://lwn.net/Articles/44139/
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>第三步：</h2>
<p>停用irqbalance
/etc/init.d/irqbalance stop
这个是一个自动调整中断的工具，有兴趣的可以看下irqbalance的官方网站：
<a class="reference external" href="http://irqbalance.org/">http://irqbalance.org/</a></p>
</div>
<div class="section" id="id4">
<h2>第四步：</h2>
<p>设置eth0、eth1对应中断号的 <tt class="docutils literal"><span class="pre">smp_affinity</span></tt> 为 “ff”
先看一下网卡的中断号：</p>
<img alt="http://farm8.staticflickr.com/7046/6928573141_959e7d24ff_z.jpg" src="http://farm8.staticflickr.com/7046/6928573141_959e7d24ff_z.jpg" style="width: 600px;"/>
<p>从图中可以看到网卡eth1的中断号为16,eth0的中断号为18
将/proc/irq/中断号/smp_affinity修改为ff，修改完成后就可以开启lvs了，现在中断应该均分到各个核心上了。</p>
<div class="highlight-bash"><div class="highlight"><pre>smp_affinity这个参数是怎么得来的？ 可参考下面链接：
http://www.cs.uwaterloo.ca/~brecht/servers/apic/SMP-affinity.txt
</pre></div>
</div>
</div>
</div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Jason Wu</span>
        </div>
        <div class="categories">
            <span>
                Filed under:
                <a href="categories/network.html">network</a></span>
        </div>
        <div class="tags">
            <span>
                Tags:
                <a class="label"; rel="tag"; href="tags/lvs.html">lvs</a>
                <a class="label"; rel="tag"; href="tags/irq.html">irq</a>
                </span>
        </div>
        <div class="comments">
            <a href="http://jasonwu.me/2012/09/08/adjust_nic_irq_for_lvs.html#disqus_thread" data-disqus-identifier="2012/09/08/adjust_nic_irq_for_lvs">Leave a comment</a>
        </div>
    </div><div class="archive_link">
        <a href="archive.html"> &mdash;  Blog Archive  &mdash; </a>
    </div><ul class="related clearfix">
            <li class="left"><a href="index.html" title="Newer">← Previous</a></li>
            <li class="right"><a href="page2.html" title="Older">Next →</a></li>
        </ul></article></div><div id="sidebar1" class="fluid-sidebar sidebar span4" role="complementary"><section><div class="widget" id="social">
    <h1>QR CODE</h1>
    <img alt="jasonwu" src="http://jasonwu.me/_static/img/qr.png">
</div></section><section><div class="widget">
    <h1>Categories</h1>
    <ul><li><a href="categories/blog.html">blog</a> (1)</li><li><a href="categories/linux.html">linux</a> (2)</li><li><a href="categories/lua.html">lua</a> (1)</li><li><a href="categories/network.html">network</a> (1)</li><li><a href="categories/nginx.html">nginx</a> (1)</li><li><a href="categories/python.html">python</a> (4)</li><li><a href="categories/security.html">security</a> (2)</li></ul>
</div></section><section><div class="widget">
    <h1>Recent Posts</h1>
    <ul><li>
            <a href="2013/06/02/search_for_an_item_in_a_lua_list.html">如何判断一个值在lua的table里</a>
        </li><li>
            <a href="2013/01/19/begin_tinkerer.html">博客迁移到tinkerer</a>
        </li><li>
            <a href="2012/12/04/use_nginx_uwsgi_deploy_django.html">使用NGINX+UWSGI来部署Django</a>
        </li><li>
            <a href="2012/12/04/the_unp_reading_notes_io_model.html">unp读书笔记（第六章I/O模型）</a>
        </li><li>
            <a href="2012/12/03/args_and_kwargs_in_python.html">Python : 什么是*args和**kwargs？</a>
        </li><li>
            <a href="2012/10/13/centos_install_cx_oracle.html">CENT OS安装cx_Oracle遇到的问题及解决方法</a>
        </li><li>
            <a href="2012/10/13/introduce_to_python_lambda.html">python的lambda函数介绍</a>
        </li><li>
            <a href="2012/09/11/detailed_lvs_difference_between_the_three_models.html">LVS的三种模式区别详解</a>
        </li><li>
            <a href="2012/09/11/vmware_several_modules_must_be_compiled_and_loaded_into_the_running_kernel.html">VMware-several-modules-must-be-compiled-and-loaded-into-the-running-kernel</a>
        </li><li>
            <a href="2012/09/08/adjust_nic_irq_for_lvs.html">LVS网卡软中断配置</a>
        </li></ul>
</div>
</section><section><div class="widget">
    <h1>Friends links</h1>
    <ul>
        <li><a href="http://www.qdyongai.cn/?from=jason">龙哥-网站设计</a></li>
        <li><a href="http://www.zipeng.info/?from=jason">子鹏-kun的记事本</a></li>
        <li><a href="http://www.aaronw.me/?from=jason">王炜-我的技术生活</a></li>
        <li><a href="http://cuikai-wh.com/?from=jason">小轰-时光立方</a></li>
    </ul>
</div></section><section><div class="widget">
    <h1>MicroBlog</h1>
    <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=6&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=1793345607&verifier=c7f905c0&dpc=1"></iframe>
</div></section></div></div> <!-- #main --></div> <!-- #main-container -->

        <div class="footer-container"><footer class="wrapper">&copy; Copyright 2013, Jason Wu. Powered by <a href="http://www.tinkerer.me/">Tinkerer</a> and <a href="http://sphinx.pocoo.org/">Sphinx</a>.</footer></div> <!-- footer-container -->

      </div> <!--! end of #container --><script type="text/javascript">    var disqus_shortname = "jasonwu";    disqus_count();</script><!--[if lt IE 7 ]>
          <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
          <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
        <![endif]-->
    </body>
</html>